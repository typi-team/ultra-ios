//
//  IncomingCallViewController.swift
//  Pods
//
//  Created by Slam on 9/4/23.
//  Copyright (c) 2023 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the üêç VIPER generator
//

import UIKit
import LiveKitClient

final class IncomingCallViewController: BaseViewController<IncomingCallPresenterInterface> {
    
    fileprivate lazy var room = Room(delegate: self)
    fileprivate lazy var timer: Timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true, block: {[weak self] timer in
        self?.infoView.setDuration(text: timer.tolerance.description)
    })

    fileprivate lazy var localVideoView: VideoView = .init({
        $0.isHidden = true
        $0.cornerRadius = kLowPadding
    })

    fileprivate lazy var remoteVideoView: VideoView = .init({
        $0.isHidden = true
        $0.cornerRadius = kLowPadding
    })

    fileprivate lazy var style: CallPageStyle = UltraCoreStyle.callingConfig

    fileprivate lazy var infoView = IncomingCallInfoView(style: style)

    fileprivate lazy var actionStackView = IncomingCallActionView(style: style, delegate: self)

    override func viewDidLoad() {
        super.viewDidLoad()

        view.backgroundColor = style.background.color
    }

    override func setupViews() {
        super.setupViews()

        view.addSubview(remoteVideoView)
        view.addSubview(infoView)
        view.addSubview(actionStackView)
        view.addSubview(localVideoView)
    }

    override func setupConstraints() {
        super.setupConstraints()

        actionStackView.snp.makeConstraints { make in
            make.bottom.equalToSuperview().offset(-54)
            make.left.equalToSuperview().offset(kHeadlinePadding)
            make.right.equalToSuperview().offset(-kHeadlinePadding)
            make.height.equalTo(52)
        }
        infoView.snp.makeConstraints { make in
            make.leading.trailing.equalToSuperview()
            make.bottom.equalTo(view.snp.centerY).offset(-36)
        }
        remoteVideoView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        localVideoView.snp.makeConstraints { make in
            make.trailing.equalToSuperview().inset(31)
            make.bottom.equalTo(actionStackView.snp.top).offset(-32)
            make.width.equalTo(90)
            make.height.equalTo(150)
        }
    }

    override func setupInitialData() {
        super.setupInitialData()

        presenter?.viewDidLoad()
        guard let status = presenter?.getCallStatus() else { return }
        actionStackView.configure(status: status)
        switch status {
        case let .incoming(request), let .outcoming(request):
            room.localParticipant?.setCamera(enabled: request.video)
        }
    }

    deinit {
        _ = self.room.disconnect()
    }
}

// MARK: - IncomingCallActionViewDelegate

extension IncomingCallViewController: IncomingCallActionViewDelegate {
    
    func view(_ view: IncomingCallActionView, answerButtonDidTap button: UIButton) {
        guard let callStatus = presenter?.getCallStatus() else { return }
        connectRoom(with: callStatus.callInfo)
    }
    
    func view(_ view: IncomingCallActionView, mouthpieceButtonDidTap button: UIButton) {
//        _ = room.localParticipant?.isSpeaking = button.isSelected
    }
    
    func view(_ view: IncomingCallActionView, microButtonDidTap button: UIButton) {
        _ = room.localParticipant?.set(source: .microphone, enabled: !button.isSelected)
    }
    
    func view(_ view: IncomingCallActionView, cameraButtonDidTap button: UIButton) {
        let cameraEnabled = button.isSelected
        _ = room.localParticipant?.setCamera(enabled: cameraEnabled)
        infoView.isHidden = cameraEnabled
        localVideoView.isHidden = !cameraEnabled
    }
    
    func view(_ view: IncomingCallActionView, cancelButtonDidTap button: UIButton) {
        infoView.setDuration(text: "Close connection")
        presenter?.cancel()
    }
    
    func view(_ view: IncomingCallActionView, rejectButtonDidTap button: UIButton) {
        infoView.setDuration(text: "Reject connection")
        presenter?.reject()
    }
    
}

// MARK: - IncomingCallViewInterface

extension IncomingCallViewController: IncomingCallViewInterface {
    func connectRoom(with callInfo: CallInformation) {
        room.connect(callInfo.host, callInfo.accessToken).then { [weak self] room in
            guard let self else { return }
            room.localParticipant?.setCamera(enabled: callInfo.video)
            room.localParticipant?.setMicrophone(enabled: false)
        }.catch { error in
            self.dismiss(animated: true)
        }
    }

    func disconnectRoom() {
        self.room.disconnect().then({[weak self] () in
            self?.navigationController?.popViewController(animated: true)
        }).catch { [weak self] error  in
            self?.navigationController?.popViewController(animated: true)
        }
    }

    func dispay(view contact: ContactDisplayable) {
        infoView.confige(view: contact)
    }
}

// MARK: - RoomDelegateObjC

extension IncomingCallViewController: RoomDelegateObjC {
    func room(_ room: Room, didUpdate connectionState: ConnectionStateObjC, oldValue oldConnectionState: ConnectionStateObjC) {
        print("[ROOM]: old - \(oldConnectionState); new - \(connectionState)")
        DispatchQueue.main.async { [weak self] in
            guard let self else { return }
            if connectionState == .connected {
                self.actionStackView.setAsActive()
            }
            self.infoView.setDuration(text: connectionState.desctiption)
            self.infoView.hidePhoneNumber()
            switch connectionState {
            case .disconnected, .connecting, .reconnecting:
                self.timer.invalidate()
            case .connected:
                self.timer.fire()
            }
        }
    }

    func room(_ room: Room, didUpdate metadata: String?) {
        PP.debug(metadata ?? "as")
    }

    func room(_ room: Room, localParticipant: LocalParticipant, didPublish publication: LocalTrackPublication) {
        guard let track = publication.track as? VideoTrack else {
            return
        }
        DispatchQueue.main.async {
            self.localVideoView.track = track
        }
    }

    func room(_ room: Room, participant: RemoteParticipant, didUpdate publication: RemoteTrackPublication, permission allowed: Bool) {
        guard let track = publication.track as? VideoTrack else {
            remoteVideoView.isHidden = true
            return
        }
        DispatchQueue.main.async { [weak self] in
            self?.remoteVideoView.isHidden = false
            self?.remoteVideoView.track = track
        }
    }

    func room(_ room: Room, participant: RemoteParticipant, didSubscribe publication: RemoteTrackPublication, track: Track) {
        guard let track = track as? VideoTrack else {
            remoteVideoView.isHidden = true
            return
        }
        DispatchQueue.main.async { [weak self] in
            self?.remoteVideoView.isHidden = false
            self?.remoteVideoView.track = track
        }
    }

    func room(_ room: Room, participant: RemoteParticipant, didUnsubscribe publication: RemoteTrackPublication, track: Track) {
        guard let track = publication.track as? VideoTrack else {
            remoteVideoView.isHidden = true
            return
        }
        DispatchQueue.main.async { [weak self] in
            self?.remoteVideoView.isHidden = false
            self?.remoteVideoView.track = track
        }
    }

    func room(_ room: Room, participant: RemoteParticipant, didUnpublish publication: RemoteTrackPublication) {
        guard let track = publication.track as? VideoTrack else {
            remoteVideoView.isHidden = true
            return
        }
        DispatchQueue.main.async { [weak self] in
            self?.remoteVideoView.isHidden = false
            self?.remoteVideoView.track = track
        }
    }

}

//MARK: - Extensions

private extension ConnectionStateObjC {
    var desctiption: String {
        switch self {
        case .connected:return CallStrings.connected.localized
        case .disconnected:
            return CallStrings.disconnected.localized
        case .connecting:
            return CallStrings.connecting.localized
        case .reconnecting:
            return CallStrings.reconnecting.localized
        }
    }
}
