//
//  ConversationsPresenter.swift
//  Pods
//
//  Created by Slam on 4/20/23.
//  Copyright (c) 2023 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the üêç VIPER generator
//

import RxSwift
import Foundation
import RealmSwift
import IGListKit

final class ConversationsPresenter: BasePresenter {

    // MARK: - Private properties -
    private let reachability = try! Reachability()
    private let updateRepository: UpdateRepository
    private let messageRepository: MessageRepository
    private unowned let view: ConversationsViewInterface
    private let wireframe: ConversationsWireframeInterface
    fileprivate let contactDBService: ContactDBService
    private let conversationRepository: ConversationRepository
    private let retrieveContactStatusesInteractor: UseCase<Void, Void>
    fileprivate let contactByUserIdInteractor: ContactByUserIdInteractor
    fileprivate let userStatusUpdateInteractor: UseCase<Bool, UpdateStatusResponse>
    fileprivate let deleteConversationInteractor: UseCase<(Conversation, Bool), Void>
    fileprivate let contactToCreateChatByPhoneInteractor: ContactToCreateChatByPhoneInteractor
    private let messageSenderInteractor: UseCase<MessageSendRequest, MessageSendResponse>
    fileprivate let mediaRepository: MediaRepository
    private var resendingMessages: Array<String> = []
    
    lazy var conversation: Observable<[Conversation]> = Observable.combineLatest(conversationRepository.conversations(), updateRepository.typingUsers)
        .map({ conversations, typingUsers in
            return conversations.map { conversation in
                var mutable = conversation
                if let typing = typingUsers[conversation.idintification] {
                    mutable.typingData.removeAll(where: {$0.userId == typing.userId})
                    mutable.typingData.append(typing)
                }
                return mutable
            }
        })
    
    // MARK: - Lifecycle -

    init(view: ConversationsViewInterface,
         updateRepository: UpdateRepository,
         messageRepository: MessageRepository,
         contactDBService: ContactDBService,
         wireframe: ConversationsWireframeInterface,
         conversationRepository: ConversationRepository,
         contactByUserIdInteractor: ContactByUserIdInteractor,
         retrieveContactStatusesInteractor: UseCase<Void, Void>,
         deleteConversationInteractor: UseCase<(Conversation,Bool), Void>,
         contactToCreateChatByPhoneInteractor: ContactToCreateChatByPhoneInteractor,
         userStatusUpdateInteractor: UseCase<Bool, UpdateStatusResponse>,
         messageSenderInteractor: UseCase<MessageSendRequest, MessageSendResponse>,
         mediaRepository: MediaRepository) {
        self.view = view
        self.wireframe = wireframe
        self.updateRepository = updateRepository
        self.messageRepository = messageRepository
        self.contactDBService = contactDBService
        self.conversationRepository = conversationRepository
        self.contactByUserIdInteractor = contactByUserIdInteractor
        self.userStatusUpdateInteractor = userStatusUpdateInteractor
        self.deleteConversationInteractor = deleteConversationInteractor
        self.retrieveContactStatusesInteractor = retrieveContactStatusesInteractor
        self.contactToCreateChatByPhoneInteractor = contactToCreateChatByPhoneInteractor
        self.messageSenderInteractor = messageSenderInteractor
        self.mediaRepository = mediaRepository
    }
}

// MARK: - Extensions -

extension ConversationsPresenter: ConversationsPresenterInterface {
    
    func viewDidLoad() {
        startReachibilityNotifier()
    }
    
    func delete(_ conversation: Conversation, all: Bool) {
        self.deleteConversationInteractor.executeSingle(params: (conversation, all))
            .subscribe(on: ConcurrentDispatchQueueScheduler(qos: .background))
            .observe(on: MainScheduler.instance)
            .subscribe()
            .disposed(by: disposeBag)
    }
    func retrieveContactStatuses() {
        self.retrieveContactStatusesInteractor.execute(params: ())
            .subscribe(on: ConcurrentDispatchQueueScheduler(qos: .background))
            .observe(on: MainScheduler.instance)
            .subscribe()
            .disposed(by: disposeBag)
    }
    
    func updateStatus(is online: Bool) {
        self.userStatusUpdateInteractor.executeSingle(params: online)
            .subscribe(on: ConcurrentDispatchQueueScheduler(qos: .background))
            .observe(on: MainScheduler.instance)
            .subscribe()
            .disposed(by: disposeBag)
    }
    
    func setupUpdateSubscription() {
        self.updateRepository.setupSubscription()
        self.updateRepository.sendPoingByTimer()
    }
    
    func navigate(to conversation: Conversation) {
        self.updateRepository.readAll(in: conversation)
        self.wireframe.navigateToConversation(with: conversation)
    }
    
    
    func navigateToContacts() {
        self.wireframe.navigateToContacts(contactsCallback: { contacts in },
                                          openConverationCallback: { [weak self] userID in
                                              guard let `self` = self else { return }
                                              self.createChatBy(contact: userID)
                                          })
    }
    
    func createChatBy(contact: IContact) {
        self.contactToCreateChatByPhoneInteractor
            .executeSingle(params: contact)
            .flatMap({ contactByPhone -> Single<Conversation> in
                self.contactByUserIdInteractor.executeSingle(params: contactByPhone.userID)
                    .flatMap({ contact in
                        self.contactDBService.save(contact: contact).map({contact})
                    }).map({ ConversationImpl(contact: $0, idintification: contactByPhone.chatID) })
                    
            })
            .subscribe(on: ConcurrentDispatchQueueScheduler(qos: .background))
            .observe(on: MainScheduler.instance)
            .subscribe(onSuccess: { [weak self] conversation in
                
                self?.wireframe.navigateToConversation(with: conversation)
            })
            .disposed(by: disposeBag)
    }
    
    private func resendConversationsIfNeeded() {
        getConversations { [weak self] conversations in
            guard let self else { return }
            conversations.forEach { conversation in
                self.getConversationByID(id: conversation.idintification) { messages in
                    let unsendedMessages = messages.filter { $0.seqNumber == 0 && !$0.isIncome }
                    unsendedMessages.forEach { message in
                        if !self.resendingMessages.contains(message.id) {
                            self.resendingMessages.append(message.id)
                            if message.content != nil {
                                self.resendFiles(
                                    message: message,
                                    conversation: conversation
                                )
                            } else {
                                self.resendMessage(message: message, conversation: conversation)
                            }
                        }
                    }
                }
            }
        }
    }
    
    private func resendMessage(message: Message, conversation: Conversation) {
        var message = message
        var params = MessageSendRequest()
        params.peer.user = .with({ peer in
            peer.userID = conversation.peer?.userID ?? "u1FNOmSc0DAwM"
        })
        params.message = message
        messageSenderInteractor
            .executeSingle(params: params)
            .flatMap({ [weak self] (response: MessageSendResponse) in
                guard let `self` = self else {
                    throw NSError.selfIsNill
                }
                message.meta.created = response.meta.created
                message.state.delivered = false
                message.state.read = false
                message.seqNumber = response.seqNumber
                return self.messageRepository.update(message: message)
            })
            .subscribe(on: ConcurrentDispatchQueueScheduler(qos: .background))
            .observe(on: MainScheduler.instance)
            .subscribe()
            .disposed(by: self.disposeBag)
    }
    
    func resendFiles(message: Message, conversation: Conversation) {
        self.mediaRepository
            .upload(message: message, in: conversation)
            .flatMap({ [weak self] request in
                guard let `self` = self else { throw NSError.selfIsNill }
                return self.messageSenderInteractor.executeSingle(params: request)
            })
            .subscribe(on: ConcurrentDispatchQueueScheduler(qos: .background))
            .observe(on: MainScheduler.instance)
            .subscribe(onSuccess: { _ in },
                       onFailure: { error in PP.debug(error.localizedDescription)
            })
            .disposed(by: disposeBag)
    }
    
    private func startReachibilityNotifier() {
        reachability.whenReachable = { [weak self] reachability in
            self?.resendConversationsIfNeeded()
        }
        try? reachability.startNotifier()
    }
    
    private func getConversations(onCompletion: @escaping ([Conversation]) -> Void) {
        conversationRepository
            .conversations()
            .compactMap({ $0 })
            .subscribe(onNext: { conversations in
                onCompletion(conversations)
            })
            .disposed(by: disposeBag)
    }
    
    private func getConversationByID(id: String, onCompletion: @escaping ([Message]) -> Void) {
        messageRepository
            .messages(chatID: id)
            .do(onNext: { messages in
                onCompletion(messages)
            })
            .subscribe()
            .disposed(by: disposeBag)
    }
  
}
