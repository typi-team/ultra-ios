// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: enumerated/enumerated.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum DeviceEnum: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case web // = 0
  case ios // = 1
  case android // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .web
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .web
    case 1: self = .ios
    case 2: self = .android
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .web: return 0
    case .ios: return 1
    case .android: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension DeviceEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [DeviceEnum] = [
    .web,
    .ios,
    .android,
  ]
}

#endif  // swift(>=4.2)

enum ChatTypeEnum: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case peerToPeer // = 0
  case simpleGroup // = 1
  case group // = 2
  case channel // = 3
  case support // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .peerToPeer
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .peerToPeer
    case 1: self = .simpleGroup
    case 2: self = .group
    case 3: self = .channel
    case 4: self = .support
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .peerToPeer: return 0
    case .simpleGroup: return 1
    case .group: return 2
    case .channel: return 3
    case .support: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ChatTypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [ChatTypeEnum] = [
    .peerToPeer,
    .simpleGroup,
    .group,
    .channel,
    .support,
  ]
}

#endif  // swift(>=4.2)

enum MessageTypeEnum: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case text // = 0
  case audio // = 1
  case voice // = 2
  case photo // = 3
  case video // = 4
  case file // = 5
  case money // = 6
  case contact // = 7
  case location // = 8
  case stock // = 9
  case coin // = 10
  case call // = 11
  case system // = 12
  case UNRECOGNIZED(Int)

  init() {
    self = .text
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .text
    case 1: self = .audio
    case 2: self = .voice
    case 3: self = .photo
    case 4: self = .video
    case 5: self = .file
    case 6: self = .money
    case 7: self = .contact
    case 8: self = .location
    case 9: self = .stock
    case 10: self = .coin
    case 11: self = .call
    case 12: self = .system
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .text: return 0
    case .audio: return 1
    case .voice: return 2
    case .photo: return 3
    case .video: return 4
    case .file: return 5
    case .money: return 6
    case .contact: return 7
    case .location: return 8
    case .stock: return 9
    case .coin: return 10
    case .call: return 11
    case .system: return 12
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MessageTypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [MessageTypeEnum] = [
    .text,
    .audio,
    .voice,
    .photo,
    .video,
    .file,
    .money,
    .contact,
    .location,
    .stock,
    .coin,
    .call,
    .system,
  ]
}

#endif  // swift(>=4.2)

enum UserStatusEnum: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case online // = 1
  case offline // = 2
  case away // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .online
    case 2: self = .offline
    case 3: self = .away
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .online: return 1
    case .offline: return 2
    case .away: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension UserStatusEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [UserStatusEnum] = [
    .unknown,
    .online,
    .offline,
    .away,
  ]
}

#endif  // swift(>=4.2)

enum UserTypeEnum: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case userTypeUnknown // = 0
  case user // = 1
  case bot // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .userTypeUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .userTypeUnknown
    case 1: self = .user
    case 2: self = .bot
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .userTypeUnknown: return 0
    case .user: return 1
    case .bot: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension UserTypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [UserTypeEnum] = [
    .userTypeUnknown,
    .user,
    .bot,
  ]
}

#endif  // swift(>=4.2)

/// Media type for using in presence sending
enum MediaTypeEnum: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case mediaUnknown // = 0
  case mediaPhoto // = 1
  case mediaVideo // = 2
  case mediaDocument // = 3
  case mediaFile // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .mediaUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .mediaUnknown
    case 1: self = .mediaPhoto
    case 2: self = .mediaVideo
    case 3: self = .mediaDocument
    case 4: self = .mediaFile
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .mediaUnknown: return 0
    case .mediaPhoto: return 1
    case .mediaVideo: return 2
    case .mediaDocument: return 3
    case .mediaFile: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MediaTypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [MediaTypeEnum] = [
    .mediaUnknown,
    .mediaPhoto,
    .mediaVideo,
    .mediaDocument,
    .mediaFile,
  ]
}

#endif  // swift(>=4.2)

enum MoneyStatusEnum: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case moneyStatusUnknown // = 0
  case inProgress // = 1
  case completed // = 2
  case rejected // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .moneyStatusUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .moneyStatusUnknown
    case 1: self = .inProgress
    case 2: self = .completed
    case 3: self = .rejected
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .moneyStatusUnknown: return 0
    case .inProgress: return 1
    case .completed: return 2
    case .rejected: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MoneyStatusEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [MoneyStatusEnum] = [
    .moneyStatusUnknown,
    .inProgress,
    .completed,
    .rejected,
  ]
}

#endif  // swift(>=4.2)

enum StockStatusEnum: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case stockStatusUnknown // = 0
  case stockStatusInProgress // = 1
  case stockStatusCompleted // = 2
  case stockStatusRejected // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .stockStatusUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .stockStatusUnknown
    case 1: self = .stockStatusInProgress
    case 2: self = .stockStatusCompleted
    case 3: self = .stockStatusRejected
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .stockStatusUnknown: return 0
    case .stockStatusInProgress: return 1
    case .stockStatusCompleted: return 2
    case .stockStatusRejected: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension StockStatusEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [StockStatusEnum] = [
    .stockStatusUnknown,
    .stockStatusInProgress,
    .stockStatusCompleted,
    .stockStatusRejected,
  ]
}

#endif  // swift(>=4.2)

enum CoinStatusEnum: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case coinStatusUnknown // = 0
  case coinStatusInProgress // = 1
  case coinStatusCompleted // = 2
  case coinStatusRejected // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .coinStatusUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .coinStatusUnknown
    case 1: self = .coinStatusInProgress
    case 2: self = .coinStatusCompleted
    case 3: self = .coinStatusRejected
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .coinStatusUnknown: return 0
    case .coinStatusInProgress: return 1
    case .coinStatusCompleted: return 2
    case .coinStatusRejected: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CoinStatusEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [CoinStatusEnum] = [
    .coinStatusUnknown,
    .coinStatusInProgress,
    .coinStatusCompleted,
    .coinStatusRejected,
  ]
}

#endif  // swift(>=4.2)

enum ComplainMessageEnum: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case received // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .received
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .received
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .received: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ComplainMessageEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [ComplainMessageEnum] = [
    .received,
  ]
}

#endif  // swift(>=4.2)

enum ComplainTypeEnum: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case abuse // = 0
  case spam // = 1
  case inappropriate // = 2
  case personalData // = 3
  case other // = 4
  case fraud // = 5
  case serviceImposition // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .abuse
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .abuse
    case 1: self = .spam
    case 2: self = .inappropriate
    case 3: self = .personalData
    case 4: self = .other
    case 5: self = .fraud
    case 6: self = .serviceImposition
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .abuse: return 0
    case .spam: return 1
    case .inappropriate: return 2
    case .personalData: return 3
    case .other: return 4
    case .fraud: return 5
    case .serviceImposition: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ComplainTypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [ComplainTypeEnum] = [
    .abuse,
    .spam,
    .inappropriate,
    .personalData,
    .other,
    .fraud,
    .serviceImposition,
  ]
}

#endif  // swift(>=4.2)

enum CallStatusEnum: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case callStatusCreated // = 0
  case callStatusStarted // = 1
  case callStatusCanceled // = 2
  case callStatusMissed // = 3
  case callStatusRejected // = 4
  case callStatusEnded // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .callStatusCreated
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .callStatusCreated
    case 1: self = .callStatusStarted
    case 2: self = .callStatusCanceled
    case 3: self = .callStatusMissed
    case 4: self = .callStatusRejected
    case 5: self = .callStatusEnded
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .callStatusCreated: return 0
    case .callStatusStarted: return 1
    case .callStatusCanceled: return 2
    case .callStatusMissed: return 3
    case .callStatusRejected: return 4
    case .callStatusEnded: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CallStatusEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [CallStatusEnum] = [
    .callStatusCreated,
    .callStatusStarted,
    .callStatusCanceled,
    .callStatusMissed,
    .callStatusRejected,
    .callStatusEnded,
  ]
}

#endif  // swift(>=4.2)

/// Available photo sizes
enum PhotoSize: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Image size with applied gaussian blur filter.
  /// Width is 100, quality will be decreased to 50%,
  /// can be used for preview photos
  case blur // = 0

  /// width=100, quality=90%, height will be changed by keeping sides ratio
  case s // = 1

  /// width=2560, quality=90%, height will be changed by keeping sides ratio
  case w // = 2

  /// width=1280, quality=90%, height will be changed by keeping sides ratio
  case y // = 3

  /// width=800, quality=90%, height will be changed by keeping sides ratio
  case x // = 4

  /// width=320, quality=90%, height will be changed by keeping sides ratio
  case m // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .blur
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .blur
    case 1: self = .s
    case 2: self = .w
    case 3: self = .y
    case 4: self = .x
    case 5: self = .m
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .blur: return 0
    case .s: return 1
    case .w: return 2
    case .y: return 3
    case .x: return 4
    case .m: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PhotoSize: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [PhotoSize] = [
    .blur,
    .s,
    .w,
    .y,
    .x,
    .m,
  ]
}

#endif  // swift(>=4.2)

enum SupportChatStatusEnum: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case supportChatStatusClosed // = 0
  case supportChatStatusPostponed // = 2
  case supportChatStatusOpen // = 3
  case supportChatStatusAny // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .supportChatStatusClosed
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .supportChatStatusClosed
    case 2: self = .supportChatStatusPostponed
    case 3: self = .supportChatStatusOpen
    case 4: self = .supportChatStatusAny
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .supportChatStatusClosed: return 0
    case .supportChatStatusPostponed: return 2
    case .supportChatStatusOpen: return 3
    case .supportChatStatusAny: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SupportChatStatusEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SupportChatStatusEnum] = [
    .supportChatStatusClosed,
    .supportChatStatusPostponed,
    .supportChatStatusOpen,
    .supportChatStatusAny,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension DeviceEnum: @unchecked Sendable {}
extension ChatTypeEnum: @unchecked Sendable {}
extension MessageTypeEnum: @unchecked Sendable {}
extension UserStatusEnum: @unchecked Sendable {}
extension UserTypeEnum: @unchecked Sendable {}
extension MediaTypeEnum: @unchecked Sendable {}
extension MoneyStatusEnum: @unchecked Sendable {}
extension StockStatusEnum: @unchecked Sendable {}
extension CoinStatusEnum: @unchecked Sendable {}
extension ComplainMessageEnum: @unchecked Sendable {}
extension ComplainTypeEnum: @unchecked Sendable {}
extension CallStatusEnum: @unchecked Sendable {}
extension PhotoSize: @unchecked Sendable {}
extension SupportChatStatusEnum: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension DeviceEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WEB"),
    1: .same(proto: "IOS"),
    2: .same(proto: "ANDROID"),
  ]
}

extension ChatTypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PEER_TO_PEER"),
    1: .same(proto: "SIMPLE_GROUP"),
    2: .same(proto: "GROUP"),
    3: .same(proto: "CHANNEL"),
    4: .same(proto: "SUPPORT"),
  ]
}

extension MessageTypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEXT"),
    1: .same(proto: "AUDIO"),
    2: .same(proto: "VOICE"),
    3: .same(proto: "PHOTO"),
    4: .same(proto: "VIDEO"),
    5: .same(proto: "FILE"),
    6: .same(proto: "MONEY"),
    7: .same(proto: "CONTACT"),
    8: .same(proto: "LOCATION"),
    9: .same(proto: "STOCK"),
    10: .same(proto: "COIN"),
    11: .same(proto: "CALL"),
    12: .same(proto: "SYSTEM"),
  ]
}

extension UserStatusEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ONLINE"),
    2: .same(proto: "OFFLINE"),
    3: .same(proto: "AWAY"),
  ]
}

extension UserTypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "USER_TYPE_UNKNOWN"),
    1: .same(proto: "USER"),
    2: .same(proto: "BOT"),
  ]
}

extension MediaTypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEDIA_UNKNOWN"),
    1: .same(proto: "MEDIA_PHOTO"),
    2: .same(proto: "MEDIA_VIDEO"),
    3: .same(proto: "MEDIA_DOCUMENT"),
    4: .same(proto: "MEDIA_FILE"),
  ]
}

extension MoneyStatusEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MONEY_STATUS_UNKNOWN"),
    1: .same(proto: "IN_PROGRESS"),
    2: .same(proto: "COMPLETED"),
    3: .same(proto: "REJECTED"),
  ]
}

extension StockStatusEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STOCK_STATUS_UNKNOWN"),
    1: .same(proto: "STOCK_STATUS_IN_PROGRESS"),
    2: .same(proto: "STOCK_STATUS_COMPLETED"),
    3: .same(proto: "STOCK_STATUS_REJECTED"),
  ]
}

extension CoinStatusEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COIN_STATUS_UNKNOWN"),
    1: .same(proto: "COIN_STATUS_IN_PROGRESS"),
    2: .same(proto: "COIN_STATUS_COMPLETED"),
    3: .same(proto: "COIN_STATUS_REJECTED"),
  ]
}

extension ComplainMessageEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RECEIVED"),
  ]
}

extension ComplainTypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ABUSE"),
    1: .same(proto: "SPAM"),
    2: .same(proto: "INAPPROPRIATE"),
    3: .same(proto: "PERSONAL_DATA"),
    4: .same(proto: "OTHER"),
    5: .same(proto: "FRAUD"),
    6: .same(proto: "SERVICE_IMPOSITION"),
  ]
}

extension CallStatusEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CALL_STATUS_CREATED"),
    1: .same(proto: "CALL_STATUS_STARTED"),
    2: .same(proto: "CALL_STATUS_CANCELED"),
    3: .same(proto: "CALL_STATUS_MISSED"),
    4: .same(proto: "CALL_STATUS_REJECTED"),
    5: .same(proto: "CALL_STATUS_ENDED"),
  ]
}

extension PhotoSize: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BLUR"),
    1: .same(proto: "S"),
    2: .same(proto: "W"),
    3: .same(proto: "Y"),
    4: .same(proto: "X"),
    5: .same(proto: "M"),
  ]
}

extension SupportChatStatusEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUPPORT_CHAT_STATUS_CLOSED"),
    2: .same(proto: "SUPPORT_CHAT_STATUS_POSTPONED"),
    3: .same(proto: "SUPPORT_CHAT_STATUS_OPEN"),
    4: .same(proto: "SUPPORT_CHAT_STATUS_ANY"),
  ]
}
