// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: common/message_types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct MessageState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var read: Bool = false

  var delivered: Bool = false

  var edited: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Money {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The three-letter currency code defined in ISO 4217.
  var currencyCode: String = String()

  /// The whole units of the amount.
  /// For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
  var units: Int64 = 0

  /// Number of nano (10^-9) units of the amount.
  /// The value must be between -999,999,999 and +999,999,999 inclusive.
  /// If `units` is positive, `nanos` must be positive or zero.
  /// If `units` is zero, `nanos` can be positive, zero, or negative.
  /// If `units` is negative, `nanos` must be negative or zero.
  /// For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
  var nanos: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MoneyStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: MoneyStatusEnum = .moneyStatusUnknown

  var message: String = String()

  var updated: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StockStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: StockStatusEnum = .stockStatusUnknown

  var message: String = String()

  var updated: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: CoinStatusEnum = .coinStatusUnknown

  var message: String = String()

  var updated: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MessageMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var created: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TextMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AudioMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fileID: String = String()

  var duration: Int64 = 0

  var fileSize: Int64 = 0

  var mimeType: String = String()

  var fileName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VoiceMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fileID: String = String()

  var duration: Int64 = 0

  var fileSize: Int64 = 0

  var mimeType: String = String()

  var fileName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PhotoMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fileID: String = String()

  var fileSize: Int64 = 0

  var mimeType: String = String()

  var fileName: String = String()

  var width: Int32 = 0

  var height: Int32 = 0

  var preview: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FileMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fileID: String = String()

  var fileSize: Int64 = 0

  var mimeType: String = String()

  var fileName: String = String()

  var preview: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LocationMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lat: Double = 0

  var lon: Double = 0

  var desc: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ContactMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var phone: String = String()

  var firstname: String = String()

  var lastname: String = String()

  var userID: String = String()

  var photo: Photo {
    get {return _photo ?? Photo()}
    set {_photo = newValue}
  }
  /// Returns true if `photo` has been explicitly set.
  var hasPhoto: Bool {return self._photo != nil}
  /// Clears the value of `photo`. Subsequent reads from it will return its default value.
  mutating func clearPhoto() {self._photo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _photo: Photo? = nil
}

struct MoneyMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var money: Money {
    get {return _money ?? Money()}
    set {_money = newValue}
  }
  /// Returns true if `money` has been explicitly set.
  var hasMoney: Bool {return self._money != nil}
  /// Clears the value of `money`. Subsequent reads from it will return its default value.
  mutating func clearMoney() {self._money = nil}

  var status: MoneyStatus {
    get {return _status ?? MoneyStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  /// Uniq transaction ID for this money transfer.
  /// Field can be empty if integration with third party is in backend,
  /// in that case transaction_id will be delivered as "update". In case
  /// integration is in client side then client should send it
  var transactionID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _money: Money? = nil
  fileprivate var _status: MoneyStatus? = nil
}

struct StockInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var logo: String = String()

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoinInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var logo: String = String()

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StockMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Uniq transaction ID for this stock transfer.
  /// Field can be empty if integration with third party is in backend,
  /// in that case transaction_id will be delivered as "update". In case
  /// integration is in client side then client should send it
  var transactionID: String = String()

  var status: StockStatus {
    get {return _status ?? StockStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var amount: Money {
    get {return _amount ?? Money()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var info: StockInfo {
    get {return _info ?? StockInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _status: StockStatus? = nil
  fileprivate var _amount: Money? = nil
  fileprivate var _info: StockInfo? = nil
}

struct CoinMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Uniq transaction ID for this coin transfer.
  /// Field can be empty if integration with third party is in backend,
  /// in that case transaction_id will be delivered as "update". In case
  /// integration is in client side then client should send it
  var transactionID: String = String()

  var status: CoinStatus {
    get {return _status ?? CoinStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var amount: Money {
    get {return _amount ?? Money()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var info: CoinInfo {
    get {return _info ?? CoinInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _status: CoinStatus? = nil
  fileprivate var _amount: Money? = nil
  fileprivate var _info: CoinInfo? = nil
}

struct VideoMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fileID: String = String()

  var duration: Int64 = 0

  var fileSize: Int64 = 0

  var mimeType: String = String()

  var fileName: String = String()

  var width: Int32 = 0

  var height: Int32 = 0

  var thumbFileID: String = String()

  var thumbPreview: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Sender {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var deviceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Receiver {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var chatID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SystemActionChatCreate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var members: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SystemActionChatEditTitle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SystemActionChatAddMember {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var members: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SystemActionChatDeleteMember {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var member: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SystemActionChatEditPhoto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var photo: Photo {
    get {return _photo ?? Photo()}
    set {_photo = newValue}
  }
  /// Returns true if `photo` has been explicitly set.
  var hasPhoto: Bool {return self._photo != nil}
  /// Clears the value of `photo`. Subsequent reads from it will return its default value.
  mutating func clearPhoto() {self._photo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _photo: Photo? = nil
}

struct SystemActionChatDeletePhoto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SystemActionSupportManagerAssigned {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SystemActionCustom {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SystemActionSupportStatusChanged {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: SupportChatStatusEnum = .supportChatStatusClosed

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var receiver: Receiver {
    get {return _storage._receiver ?? Receiver()}
    set {_uniqueStorage()._receiver = newValue}
  }
  /// Returns true if `receiver` has been explicitly set.
  var hasReceiver: Bool {return _storage._receiver != nil}
  /// Clears the value of `receiver`. Subsequent reads from it will return its default value.
  mutating func clearReceiver() {_uniqueStorage()._receiver = nil}

  var sender: Sender {
    get {return _storage._sender ?? Sender()}
    set {_uniqueStorage()._sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  var hasSender: Bool {return _storage._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  mutating func clearSender() {_uniqueStorage()._sender = nil}

  var state: MessageState {
    get {return _storage._state ?? MessageState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {_uniqueStorage()._state = nil}

  var meta: MessageMeta {
    get {return _storage._meta ?? MessageMeta()}
    set {_uniqueStorage()._meta = newValue}
  }
  /// Returns true if `meta` has been explicitly set.
  var hasMeta: Bool {return _storage._meta != nil}
  /// Clears the value of `meta`. Subsequent reads from it will return its default value.
  mutating func clearMeta() {_uniqueStorage()._meta = nil}

  var chatType: ChatTypeEnum {
    get {return _storage._chatType}
    set {_uniqueStorage()._chatType = newValue}
  }

  var seqNumber: UInt64 {
    get {return _storage._seqNumber}
    set {_uniqueStorage()._seqNumber = newValue}
  }

  var type: MessageTypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var text: String {
    get {return _storage._text}
    set {_uniqueStorage()._text = newValue}
  }

  var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  var audio: AudioMessage {
    get {
      if case .audio(let v)? = _storage._content {return v}
      return AudioMessage()
    }
    set {_uniqueStorage()._content = .audio(newValue)}
  }

  var voice: VoiceMessage {
    get {
      if case .voice(let v)? = _storage._content {return v}
      return VoiceMessage()
    }
    set {_uniqueStorage()._content = .voice(newValue)}
  }

  var photo: PhotoMessage {
    get {
      if case .photo(let v)? = _storage._content {return v}
      return PhotoMessage()
    }
    set {_uniqueStorage()._content = .photo(newValue)}
  }

  var video: VideoMessage {
    get {
      if case .video(let v)? = _storage._content {return v}
      return VideoMessage()
    }
    set {_uniqueStorage()._content = .video(newValue)}
  }

  var money: MoneyMessage {
    get {
      if case .money(let v)? = _storage._content {return v}
      return MoneyMessage()
    }
    set {_uniqueStorage()._content = .money(newValue)}
  }

  var location: LocationMessage {
    get {
      if case .location(let v)? = _storage._content {return v}
      return LocationMessage()
    }
    set {_uniqueStorage()._content = .location(newValue)}
  }

  var file: FileMessage {
    get {
      if case .file(let v)? = _storage._content {return v}
      return FileMessage()
    }
    set {_uniqueStorage()._content = .file(newValue)}
  }

  var contact: ContactMessage {
    get {
      if case .contact(let v)? = _storage._content {return v}
      return ContactMessage()
    }
    set {_uniqueStorage()._content = .contact(newValue)}
  }

  var stock: StockMessage {
    get {
      if case .stock(let v)? = _storage._content {return v}
      return StockMessage()
    }
    set {_uniqueStorage()._content = .stock(newValue)}
  }

  var coin: CoinMessage {
    get {
      if case .coin(let v)? = _storage._content {return v}
      return CoinMessage()
    }
    set {_uniqueStorage()._content = .coin(newValue)}
  }

  var call: CallMessage {
    get {
      if case .call(let v)? = _storage._content {return v}
      return CallMessage()
    }
    set {_uniqueStorage()._content = .call(newValue)}
  }

  var systemAction: OneOf_SystemAction? {
    get {return _storage._systemAction}
    set {_uniqueStorage()._systemAction = newValue}
  }

  var chatCreated: SystemActionChatCreate {
    get {
      if case .chatCreated(let v)? = _storage._systemAction {return v}
      return SystemActionChatCreate()
    }
    set {_uniqueStorage()._systemAction = .chatCreated(newValue)}
  }

  var titleEdited: SystemActionChatEditTitle {
    get {
      if case .titleEdited(let v)? = _storage._systemAction {return v}
      return SystemActionChatEditTitle()
    }
    set {_uniqueStorage()._systemAction = .titleEdited(newValue)}
  }

  var membersAdded: SystemActionChatAddMember {
    get {
      if case .membersAdded(let v)? = _storage._systemAction {return v}
      return SystemActionChatAddMember()
    }
    set {_uniqueStorage()._systemAction = .membersAdded(newValue)}
  }

  var memberDeleted: SystemActionChatDeleteMember {
    get {
      if case .memberDeleted(let v)? = _storage._systemAction {return v}
      return SystemActionChatDeleteMember()
    }
    set {_uniqueStorage()._systemAction = .memberDeleted(newValue)}
  }

  var photoEdited: SystemActionChatEditPhoto {
    get {
      if case .photoEdited(let v)? = _storage._systemAction {return v}
      return SystemActionChatEditPhoto()
    }
    set {_uniqueStorage()._systemAction = .photoEdited(newValue)}
  }

  var photoDeleted: SystemActionChatDeletePhoto {
    get {
      if case .photoDeleted(let v)? = _storage._systemAction {return v}
      return SystemActionChatDeletePhoto()
    }
    set {_uniqueStorage()._systemAction = .photoDeleted(newValue)}
  }

  var supportManagerAssigned: SystemActionSupportManagerAssigned {
    get {
      if case .supportManagerAssigned(let v)? = _storage._systemAction {return v}
      return SystemActionSupportManagerAssigned()
    }
    set {_uniqueStorage()._systemAction = .supportManagerAssigned(newValue)}
  }

  var supportStatusChanged: SystemActionSupportStatusChanged {
    get {
      if case .supportStatusChanged(let v)? = _storage._systemAction {return v}
      return SystemActionSupportStatusChanged()
    }
    set {_uniqueStorage()._systemAction = .supportStatusChanged(newValue)}
  }

  var customTextSended: SystemActionCustom {
    get {
      if case .customTextSended(let v)? = _storage._systemAction {return v}
      return SystemActionCustom()
    }
    set {_uniqueStorage()._systemAction = .customTextSended(newValue)}
  }

  var properties: Dictionary<String,String> {
    get {return _storage._properties}
    set {_uniqueStorage()._properties = newValue}
  }

  var hidden: Bool {
    get {return _storage._hidden}
    set {_uniqueStorage()._hidden = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case audio(AudioMessage)
    case voice(VoiceMessage)
    case photo(PhotoMessage)
    case video(VideoMessage)
    case money(MoneyMessage)
    case location(LocationMessage)
    case file(FileMessage)
    case contact(ContactMessage)
    case stock(StockMessage)
    case coin(CoinMessage)
    case call(CallMessage)

  #if !swift(>=4.1)
    static func ==(lhs: Message.OneOf_Content, rhs: Message.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.audio, .audio): return {
        guard case .audio(let l) = lhs, case .audio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.voice, .voice): return {
        guard case .voice(let l) = lhs, case .voice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.photo, .photo): return {
        guard case .photo(let l) = lhs, case .photo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.video, .video): return {
        guard case .video(let l) = lhs, case .video(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.money, .money): return {
        guard case .money(let l) = lhs, case .money(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.location, .location): return {
        guard case .location(let l) = lhs, case .location(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.file, .file): return {
        guard case .file(let l) = lhs, case .file(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contact, .contact): return {
        guard case .contact(let l) = lhs, case .contact(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stock, .stock): return {
        guard case .stock(let l) = lhs, case .stock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.coin, .coin): return {
        guard case .coin(let l) = lhs, case .coin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.call, .call): return {
        guard case .call(let l) = lhs, case .call(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum OneOf_SystemAction: Equatable {
    case chatCreated(SystemActionChatCreate)
    case titleEdited(SystemActionChatEditTitle)
    case membersAdded(SystemActionChatAddMember)
    case memberDeleted(SystemActionChatDeleteMember)
    case photoEdited(SystemActionChatEditPhoto)
    case photoDeleted(SystemActionChatDeletePhoto)
    case supportManagerAssigned(SystemActionSupportManagerAssigned)
    case supportStatusChanged(SystemActionSupportStatusChanged)
    case customTextSended(SystemActionCustom)

  #if !swift(>=4.1)
    static func ==(lhs: Message.OneOf_SystemAction, rhs: Message.OneOf_SystemAction) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.chatCreated, .chatCreated): return {
        guard case .chatCreated(let l) = lhs, case .chatCreated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.titleEdited, .titleEdited): return {
        guard case .titleEdited(let l) = lhs, case .titleEdited(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.membersAdded, .membersAdded): return {
        guard case .membersAdded(let l) = lhs, case .membersAdded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.memberDeleted, .memberDeleted): return {
        guard case .memberDeleted(let l) = lhs, case .memberDeleted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.photoEdited, .photoEdited): return {
        guard case .photoEdited(let l) = lhs, case .photoEdited(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.photoDeleted, .photoDeleted): return {
        guard case .photoDeleted(let l) = lhs, case .photoDeleted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.supportManagerAssigned, .supportManagerAssigned): return {
        guard case .supportManagerAssigned(let l) = lhs, case .supportManagerAssigned(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.supportStatusChanged, .supportStatusChanged): return {
        guard case .supportStatusChanged(let l) = lhs, case .supportStatusChanged(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.customTextSended, .customTextSended): return {
        guard case .customTextSended(let l) = lhs, case .customTextSended(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents messages range based on sequence number 
/// of message
struct MessagesRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only required property. For example if required to mark
  /// only one message as "read" or "delivered" only this value 
  /// can be provided
  var maxSeqNumber: UInt64 = 0

  /// Minimal seq number of messages range. If not provided then
  /// it's requal to "max_seq_number"
  var minSeqNumber: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CallMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: CallStatusEnum = .callStatusCreated

  /// timestamp in unix micro
  var startTime: Int64 = 0

  /// timestamp in unix micro
  var endTime: Int64 = 0

  /// room id/name
  var room: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension MessageState: @unchecked Sendable {}
extension Money: @unchecked Sendable {}
extension MoneyStatus: @unchecked Sendable {}
extension StockStatus: @unchecked Sendable {}
extension CoinStatus: @unchecked Sendable {}
extension MessageMeta: @unchecked Sendable {}
extension TextMessage: @unchecked Sendable {}
extension AudioMessage: @unchecked Sendable {}
extension VoiceMessage: @unchecked Sendable {}
extension PhotoMessage: @unchecked Sendable {}
extension FileMessage: @unchecked Sendable {}
extension LocationMessage: @unchecked Sendable {}
extension ContactMessage: @unchecked Sendable {}
extension MoneyMessage: @unchecked Sendable {}
extension StockInfo: @unchecked Sendable {}
extension CoinInfo: @unchecked Sendable {}
extension StockMessage: @unchecked Sendable {}
extension CoinMessage: @unchecked Sendable {}
extension VideoMessage: @unchecked Sendable {}
extension Sender: @unchecked Sendable {}
extension Receiver: @unchecked Sendable {}
extension SystemActionChatCreate: @unchecked Sendable {}
extension SystemActionChatEditTitle: @unchecked Sendable {}
extension SystemActionChatAddMember: @unchecked Sendable {}
extension SystemActionChatDeleteMember: @unchecked Sendable {}
extension SystemActionChatEditPhoto: @unchecked Sendable {}
extension SystemActionChatDeletePhoto: @unchecked Sendable {}
extension SystemActionSupportManagerAssigned: @unchecked Sendable {}
extension SystemActionCustom: @unchecked Sendable {}
extension SystemActionSupportStatusChanged: @unchecked Sendable {}
extension Message: @unchecked Sendable {}
extension Message.OneOf_Content: @unchecked Sendable {}
extension Message.OneOf_SystemAction: @unchecked Sendable {}
extension MessagesRange: @unchecked Sendable {}
extension CallMessage: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension MessageState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MessageState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "read"),
    2: .same(proto: "delivered"),
    3: .same(proto: "edited"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.read) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.delivered) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.edited) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.read != false {
      try visitor.visitSingularBoolField(value: self.read, fieldNumber: 1)
    }
    if self.delivered != false {
      try visitor.visitSingularBoolField(value: self.delivered, fieldNumber: 2)
    }
    if self.edited != 0 {
      try visitor.visitSingularInt64Field(value: self.edited, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MessageState, rhs: MessageState) -> Bool {
    if lhs.read != rhs.read {return false}
    if lhs.delivered != rhs.delivered {return false}
    if lhs.edited != rhs.edited {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Money: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Money"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "currency_code"),
    2: .same(proto: "units"),
    3: .same(proto: "nanos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.currencyCode) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.units) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.nanos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.currencyCode.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyCode, fieldNumber: 1)
    }
    if self.units != 0 {
      try visitor.visitSingularInt64Field(value: self.units, fieldNumber: 2)
    }
    if self.nanos != 0 {
      try visitor.visitSingularInt32Field(value: self.nanos, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Money, rhs: Money) -> Bool {
    if lhs.currencyCode != rhs.currencyCode {return false}
    if lhs.units != rhs.units {return false}
    if lhs.nanos != rhs.nanos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MoneyStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MoneyStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "message"),
    3: .same(proto: "updated"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.updated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .moneyStatusUnknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.updated != 0 {
      try visitor.visitSingularInt64Field(value: self.updated, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MoneyStatus, rhs: MoneyStatus) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.message != rhs.message {return false}
    if lhs.updated != rhs.updated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StockStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StockStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "message"),
    3: .same(proto: "updated"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.updated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .stockStatusUnknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.updated != 0 {
      try visitor.visitSingularInt64Field(value: self.updated, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StockStatus, rhs: StockStatus) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.message != rhs.message {return false}
    if lhs.updated != rhs.updated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CoinStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "message"),
    3: .same(proto: "updated"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.updated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .coinStatusUnknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.updated != 0 {
      try visitor.visitSingularInt64Field(value: self.updated, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinStatus, rhs: CoinStatus) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.message != rhs.message {return false}
    if lhs.updated != rhs.updated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessageMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MessageMeta"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "created"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.created) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.created != 0 {
      try visitor.visitSingularInt64Field(value: self.created, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MessageMeta, rhs: MessageMeta) -> Bool {
    if lhs.created != rhs.created {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TextMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TextMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TextMessage, rhs: TextMessage) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AudioMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AudioMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_id"),
    2: .same(proto: "duration"),
    3: .standard(proto: "file_size"),
    4: .standard(proto: "mime_type"),
    5: .standard(proto: "file_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.fileSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileID.isEmpty {
      try visitor.visitSingularStringField(value: self.fileID, fieldNumber: 1)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 2)
    }
    if self.fileSize != 0 {
      try visitor.visitSingularInt64Field(value: self.fileSize, fieldNumber: 3)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 4)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AudioMessage, rhs: AudioMessage) -> Bool {
    if lhs.fileID != rhs.fileID {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.fileSize != rhs.fileSize {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VoiceMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VoiceMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_id"),
    2: .same(proto: "duration"),
    3: .standard(proto: "file_size"),
    4: .standard(proto: "mime_type"),
    5: .standard(proto: "file_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.fileSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileID.isEmpty {
      try visitor.visitSingularStringField(value: self.fileID, fieldNumber: 1)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 2)
    }
    if self.fileSize != 0 {
      try visitor.visitSingularInt64Field(value: self.fileSize, fieldNumber: 3)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 4)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VoiceMessage, rhs: VoiceMessage) -> Bool {
    if lhs.fileID != rhs.fileID {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.fileSize != rhs.fileSize {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PhotoMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PhotoMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_id"),
    2: .standard(proto: "file_size"),
    3: .standard(proto: "mime_type"),
    4: .standard(proto: "file_name"),
    5: .same(proto: "width"),
    6: .same(proto: "height"),
    8: .same(proto: "preview"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.fileSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.preview) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileID.isEmpty {
      try visitor.visitSingularStringField(value: self.fileID, fieldNumber: 1)
    }
    if self.fileSize != 0 {
      try visitor.visitSingularInt64Field(value: self.fileSize, fieldNumber: 2)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 3)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 4)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 5)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 6)
    }
    if !self.preview.isEmpty {
      try visitor.visitSingularBytesField(value: self.preview, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PhotoMessage, rhs: PhotoMessage) -> Bool {
    if lhs.fileID != rhs.fileID {return false}
    if lhs.fileSize != rhs.fileSize {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.preview != rhs.preview {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FileMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_id"),
    2: .standard(proto: "file_size"),
    3: .standard(proto: "mime_type"),
    4: .standard(proto: "file_name"),
    5: .same(proto: "preview"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.fileSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.preview) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileID.isEmpty {
      try visitor.visitSingularStringField(value: self.fileID, fieldNumber: 1)
    }
    if self.fileSize != 0 {
      try visitor.visitSingularInt64Field(value: self.fileSize, fieldNumber: 2)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 3)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 4)
    }
    if !self.preview.isEmpty {
      try visitor.visitSingularBytesField(value: self.preview, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FileMessage, rhs: FileMessage) -> Bool {
    if lhs.fileID != rhs.fileID {return false}
    if lhs.fileSize != rhs.fileSize {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.preview != rhs.preview {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LocationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LocationMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lat"),
    2: .same(proto: "lon"),
    3: .same(proto: "desc"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.lat) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.lon) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.desc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lat != 0 {
      try visitor.visitSingularDoubleField(value: self.lat, fieldNumber: 1)
    }
    if self.lon != 0 {
      try visitor.visitSingularDoubleField(value: self.lon, fieldNumber: 2)
    }
    if !self.desc.isEmpty {
      try visitor.visitSingularStringField(value: self.desc, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LocationMessage, rhs: LocationMessage) -> Bool {
    if lhs.lat != rhs.lat {return false}
    if lhs.lon != rhs.lon {return false}
    if lhs.desc != rhs.desc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ContactMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ContactMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "firstname"),
    3: .same(proto: "lastname"),
    4: .standard(proto: "user_id"),
    5: .same(proto: "photo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.firstname) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.lastname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._photo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if !self.firstname.isEmpty {
      try visitor.visitSingularStringField(value: self.firstname, fieldNumber: 2)
    }
    if !self.lastname.isEmpty {
      try visitor.visitSingularStringField(value: self.lastname, fieldNumber: 3)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 4)
    }
    try { if let v = self._photo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ContactMessage, rhs: ContactMessage) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.firstname != rhs.firstname {return false}
    if lhs.lastname != rhs.lastname {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._photo != rhs._photo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MoneyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MoneyMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "money"),
    2: .same(proto: "status"),
    3: .standard(proto: "transaction_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._money) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._money {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MoneyMessage, rhs: MoneyMessage) -> Bool {
    if lhs._money != rhs._money {return false}
    if lhs._status != rhs._status {return false}
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StockInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StockInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "logo"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.logo) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logo.isEmpty {
      try visitor.visitSingularStringField(value: self.logo, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StockInfo, rhs: StockInfo) -> Bool {
    if lhs.logo != rhs.logo {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CoinInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "logo"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.logo) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logo.isEmpty {
      try visitor.visitSingularStringField(value: self.logo, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinInfo, rhs: CoinInfo) -> Bool {
    if lhs.logo != rhs.logo {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StockMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StockMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
    2: .same(proto: "status"),
    3: .same(proto: "amount"),
    4: .same(proto: "info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StockMessage, rhs: StockMessage) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs._status != rhs._status {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoinMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CoinMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
    2: .same(proto: "status"),
    3: .same(proto: "amount"),
    4: .same(proto: "info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._amount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoinMessage, rhs: CoinMessage) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs._status != rhs._status {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VideoMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VideoMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_id"),
    2: .same(proto: "duration"),
    3: .standard(proto: "file_size"),
    4: .standard(proto: "mime_type"),
    5: .standard(proto: "file_name"),
    6: .same(proto: "width"),
    7: .same(proto: "height"),
    8: .standard(proto: "thumb_file_id"),
    9: .standard(proto: "thumb_preview"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.duration) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.fileSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.thumbFileID) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.thumbPreview) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileID.isEmpty {
      try visitor.visitSingularStringField(value: self.fileID, fieldNumber: 1)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 2)
    }
    if self.fileSize != 0 {
      try visitor.visitSingularInt64Field(value: self.fileSize, fieldNumber: 3)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 4)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 5)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 6)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 7)
    }
    if !self.thumbFileID.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbFileID, fieldNumber: 8)
    }
    if !self.thumbPreview.isEmpty {
      try visitor.visitSingularBytesField(value: self.thumbPreview, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VideoMessage, rhs: VideoMessage) -> Bool {
    if lhs.fileID != rhs.fileID {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.fileSize != rhs.fileSize {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.thumbFileID != rhs.thumbFileID {return false}
    if lhs.thumbPreview != rhs.thumbPreview {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sender: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Sender"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "device_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sender, rhs: Sender) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Receiver: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Receiver"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "chat_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chatID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.chatID.isEmpty {
      try visitor.visitSingularStringField(value: self.chatID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Receiver, rhs: Receiver) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.chatID != rhs.chatID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SystemActionChatCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SystemActionChatCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    3: .same(proto: "members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.members) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedStringField(value: self.members, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SystemActionChatCreate, rhs: SystemActionChatCreate) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SystemActionChatEditTitle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SystemActionChatEditTitle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SystemActionChatEditTitle, rhs: SystemActionChatEditTitle) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SystemActionChatAddMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SystemActionChatAddMember"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.members) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.members.isEmpty {
      try visitor.visitRepeatedStringField(value: self.members, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SystemActionChatAddMember, rhs: SystemActionChatAddMember) -> Bool {
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SystemActionChatDeleteMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SystemActionChatDeleteMember"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "member"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.member) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.member.isEmpty {
      try visitor.visitSingularStringField(value: self.member, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SystemActionChatDeleteMember, rhs: SystemActionChatDeleteMember) -> Bool {
    if lhs.member != rhs.member {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SystemActionChatEditPhoto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SystemActionChatEditPhoto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "photo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._photo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._photo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SystemActionChatEditPhoto, rhs: SystemActionChatEditPhoto) -> Bool {
    if lhs._photo != rhs._photo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SystemActionChatDeletePhoto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SystemActionChatDeletePhoto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SystemActionChatDeletePhoto, rhs: SystemActionChatDeletePhoto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SystemActionSupportManagerAssigned: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SystemActionSupportManagerAssigned"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SystemActionSupportManagerAssigned, rhs: SystemActionSupportManagerAssigned) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SystemActionCustom: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SystemActionCustom"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SystemActionCustom, rhs: SystemActionCustom) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SystemActionSupportStatusChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SystemActionSupportStatusChanged"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .supportChatStatusClosed {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SystemActionSupportStatusChanged, rhs: SystemActionSupportStatusChanged) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Message"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "receiver"),
    3: .same(proto: "sender"),
    4: .same(proto: "state"),
    5: .same(proto: "meta"),
    6: .standard(proto: "chat_type"),
    7: .standard(proto: "seq_number"),
    8: .same(proto: "type"),
    9: .same(proto: "text"),
    10: .same(proto: "audio"),
    11: .same(proto: "voice"),
    12: .same(proto: "photo"),
    13: .same(proto: "video"),
    14: .same(proto: "money"),
    15: .same(proto: "location"),
    16: .same(proto: "file"),
    17: .same(proto: "contact"),
    18: .same(proto: "stock"),
    19: .same(proto: "coin"),
    20: .same(proto: "call"),
    21: .same(proto: "chatCreated"),
    22: .same(proto: "titleEdited"),
    23: .same(proto: "membersAdded"),
    24: .same(proto: "memberDeleted"),
    25: .same(proto: "photoEdited"),
    26: .same(proto: "photoDeleted"),
    27: .same(proto: "supportManagerAssigned"),
    28: .same(proto: "supportStatusChanged"),
    30: .same(proto: "customTextSended"),
    29: .same(proto: "properties"),
    31: .same(proto: "hidden"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _receiver: Receiver? = nil
    var _sender: Sender? = nil
    var _state: MessageState? = nil
    var _meta: MessageMeta? = nil
    var _chatType: ChatTypeEnum = .peerToPeer
    var _seqNumber: UInt64 = 0
    var _type: MessageTypeEnum = .text
    var _text: String = String()
    var _content: Message.OneOf_Content?
    var _systemAction: Message.OneOf_SystemAction?
    var _properties: Dictionary<String,String> = [:]
    var _hidden: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _receiver = source._receiver
      _sender = source._sender
      _state = source._state
      _meta = source._meta
      _chatType = source._chatType
      _seqNumber = source._seqNumber
      _type = source._type
      _text = source._text
      _content = source._content
      _systemAction = source._systemAction
      _properties = source._properties
      _hidden = source._hidden
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._receiver) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._sender) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._state) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._meta) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._chatType) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._seqNumber) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._text) }()
        case 10: try {
          var v: AudioMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .audio(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .audio(v)
          }
        }()
        case 11: try {
          var v: VoiceMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .voice(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .voice(v)
          }
        }()
        case 12: try {
          var v: PhotoMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .photo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .photo(v)
          }
        }()
        case 13: try {
          var v: VideoMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .video(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .video(v)
          }
        }()
        case 14: try {
          var v: MoneyMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .money(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .money(v)
          }
        }()
        case 15: try {
          var v: LocationMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .location(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .location(v)
          }
        }()
        case 16: try {
          var v: FileMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .file(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .file(v)
          }
        }()
        case 17: try {
          var v: ContactMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .contact(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .contact(v)
          }
        }()
        case 18: try {
          var v: StockMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .stock(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .stock(v)
          }
        }()
        case 19: try {
          var v: CoinMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .coin(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .coin(v)
          }
        }()
        case 20: try {
          var v: CallMessage?
          var hadOneofValue = false
          if let current = _storage._content {
            hadOneofValue = true
            if case .call(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._content = .call(v)
          }
        }()
        case 21: try {
          var v: SystemActionChatCreate?
          var hadOneofValue = false
          if let current = _storage._systemAction {
            hadOneofValue = true
            if case .chatCreated(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._systemAction = .chatCreated(v)
          }
        }()
        case 22: try {
          var v: SystemActionChatEditTitle?
          var hadOneofValue = false
          if let current = _storage._systemAction {
            hadOneofValue = true
            if case .titleEdited(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._systemAction = .titleEdited(v)
          }
        }()
        case 23: try {
          var v: SystemActionChatAddMember?
          var hadOneofValue = false
          if let current = _storage._systemAction {
            hadOneofValue = true
            if case .membersAdded(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._systemAction = .membersAdded(v)
          }
        }()
        case 24: try {
          var v: SystemActionChatDeleteMember?
          var hadOneofValue = false
          if let current = _storage._systemAction {
            hadOneofValue = true
            if case .memberDeleted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._systemAction = .memberDeleted(v)
          }
        }()
        case 25: try {
          var v: SystemActionChatEditPhoto?
          var hadOneofValue = false
          if let current = _storage._systemAction {
            hadOneofValue = true
            if case .photoEdited(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._systemAction = .photoEdited(v)
          }
        }()
        case 26: try {
          var v: SystemActionChatDeletePhoto?
          var hadOneofValue = false
          if let current = _storage._systemAction {
            hadOneofValue = true
            if case .photoDeleted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._systemAction = .photoDeleted(v)
          }
        }()
        case 27: try {
          var v: SystemActionSupportManagerAssigned?
          var hadOneofValue = false
          if let current = _storage._systemAction {
            hadOneofValue = true
            if case .supportManagerAssigned(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._systemAction = .supportManagerAssigned(v)
          }
        }()
        case 28: try {
          var v: SystemActionSupportStatusChanged?
          var hadOneofValue = false
          if let current = _storage._systemAction {
            hadOneofValue = true
            if case .supportStatusChanged(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._systemAction = .supportStatusChanged(v)
          }
        }()
        case 29: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._properties) }()
        case 30: try {
          var v: SystemActionCustom?
          var hadOneofValue = false
          if let current = _storage._systemAction {
            hadOneofValue = true
            if case .customTextSended(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._systemAction = .customTextSended(v)
          }
        }()
        case 31: try { try decoder.decodeSingularBoolField(value: &_storage._hidden) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._receiver {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._sender {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._meta {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._chatType != .peerToPeer {
        try visitor.visitSingularEnumField(value: _storage._chatType, fieldNumber: 6)
      }
      if _storage._seqNumber != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._seqNumber, fieldNumber: 7)
      }
      if _storage._type != .text {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 8)
      }
      if !_storage._text.isEmpty {
        try visitor.visitSingularStringField(value: _storage._text, fieldNumber: 9)
      }
      switch _storage._content {
      case .audio?: try {
        guard case .audio(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .voice?: try {
        guard case .voice(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .photo?: try {
        guard case .photo(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .video?: try {
        guard case .video(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .money?: try {
        guard case .money(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .location?: try {
        guard case .location(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .file?: try {
        guard case .file(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .contact?: try {
        guard case .contact(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .stock?: try {
        guard case .stock(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .coin?: try {
        guard case .coin(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .call?: try {
        guard case .call(let v)? = _storage._content else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case nil: break
      }
      switch _storage._systemAction {
      case .chatCreated?: try {
        guard case .chatCreated(let v)? = _storage._systemAction else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .titleEdited?: try {
        guard case .titleEdited(let v)? = _storage._systemAction else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .membersAdded?: try {
        guard case .membersAdded(let v)? = _storage._systemAction else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .memberDeleted?: try {
        guard case .memberDeleted(let v)? = _storage._systemAction else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      case .photoEdited?: try {
        guard case .photoEdited(let v)? = _storage._systemAction else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }()
      case .photoDeleted?: try {
        guard case .photoDeleted(let v)? = _storage._systemAction else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }()
      case .supportManagerAssigned?: try {
        guard case .supportManagerAssigned(let v)? = _storage._systemAction else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }()
      case .supportStatusChanged?: try {
        guard case .supportStatusChanged(let v)? = _storage._systemAction else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }()
      default: break
      }
      if !_storage._properties.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._properties, fieldNumber: 29)
      }
      try { if case .customTextSended(let v)? = _storage._systemAction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      if _storage._hidden != false {
        try visitor.visitSingularBoolField(value: _storage._hidden, fieldNumber: 31)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Message, rhs: Message) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._receiver != rhs_storage._receiver {return false}
        if _storage._sender != rhs_storage._sender {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._meta != rhs_storage._meta {return false}
        if _storage._chatType != rhs_storage._chatType {return false}
        if _storage._seqNumber != rhs_storage._seqNumber {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._text != rhs_storage._text {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._systemAction != rhs_storage._systemAction {return false}
        if _storage._properties != rhs_storage._properties {return false}
        if _storage._hidden != rhs_storage._hidden {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MessagesRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MessagesRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "max_seq_number"),
    3: .standard(proto: "min_seq_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.maxSeqNumber) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.minSeqNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxSeqNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxSeqNumber, fieldNumber: 2)
    }
    if self.minSeqNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.minSeqNumber, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MessagesRange, rhs: MessagesRange) -> Bool {
    if lhs.maxSeqNumber != rhs.maxSeqNumber {return false}
    if lhs.minSeqNumber != rhs.minSeqNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CallMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CallMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "start_time"),
    3: .standard(proto: "end_time"),
    4: .same(proto: "room"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.startTime) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.endTime) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.room) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .callStatusCreated {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if self.startTime != 0 {
      try visitor.visitSingularInt64Field(value: self.startTime, fieldNumber: 2)
    }
    if self.endTime != 0 {
      try visitor.visitSingularInt64Field(value: self.endTime, fieldNumber: 3)
    }
    if !self.room.isEmpty {
      try visitor.visitSingularStringField(value: self.room, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CallMessage, rhs: CallMessage) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.room != rhs.room {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
